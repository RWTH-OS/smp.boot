#!/bin/bash

CFLAGS="-m64 -c -O -Wall -Wno-main -O -fstrength-reduce -fomit-frame-pointer -finline-functions -nostdinc -fno-builtin -I . -ffreestanding -mcmodel=large -nostdlib -mno-red-zone -mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow"

gcc $CFLAGS -o main.o main.c
gcc $CFLAGS -o scrn.o scrn.c
gcc $CFLAGS -o lib.o lib.c
ld -nostdlib -nodefaultlibs -T link64.ld -o kernel64.elf64 main.o scrn.o lib.o


# I assume that you've already compiled and linked your 64-bit kernel
 
 
# your 64-bit kernel
kernel64="kernel64.elf64"
 
# its base address -- make sure it doesn't overlap with the kernel32 sections!
kernel64_baseaddress="0x00140000"
 
# the symbols from it you want available in your 32-bit loader
#kernel64export32_symbols="k_GDT k_GDTptr k_PML4 k_PML3 k_PML2 k_PML1_first8M kinit64 k_multibootdata k64_sbss k64_ebss k_pages k_npages"
kernel64export32_symbols="main"
 
 
kernel64export32_ldscript=tmp1 #`mktemp`
kernel64_section=tmp2   #`mktemp`
 
 
# generate .kernel64 section's data
readelf -SW "$kernel64" | python -c "`cat <<EOF
import re, sys
regex=r"\[\s*\d+\]\s*(?!NULL)(\S+)\s+(PROGBITS|NOBITS)\s+([0-9a-fA-F]+)\s+([0-9a-fA-F]+)\s+([0-9a-fA-F]+)"
baseaddress=$kernel64_baseaddress
k64f = open("$kernel64", "r")
f = open("$kernel64_section", "w")
for line in sys.stdin:
	r = re.search(regex, line)
	if not r:
		continue
	section, stype, LMA, offset, size = r.groups()
	LMA, offset, size = map(lambda s: int(s, 16), (LMA, offset, size))
	if LMA < baseaddress:
		raise ValueError("section ('%s' offset=0x%08x size=0x%08x ) at address < 0x%x" % (section, offset, size, baseaddress))
	k64f.seek(offset)
	if stype == "PROGBITS":
		f.seek(LMA-baseaddress)
		f.write(k64f.read(size))
f.close()
EOF`" || fail
 
# export wanted symbols from kernel64
readelf -sW "$kernel64" | python -c "`cat <<EOF
import re, sys
regex=r"\s*\:\s+([0-9a-fA-F]+)\s+\d+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+)"
syms=filter(len,"$kernel64export32_symbols".split(" "))
f = open("$kernel64export32_ldscript", "w")
for line in sys.stdin:
	r = re.search(regex, line)
	if not r:
		continue
	val, sym = r.groups()
	if not sym in syms:
		continue
	val = int(val, 16)
	if val > 0xffffffff:
		raise ValueError("symbol value must be below 0xffffffff limit")
	f.write('"%s" = %s;\n' % (sym, hex(val)))
f.close()
EOF`" || fail
 

# now we have to build the 32-bit loader
 
# your actual lines may vary, change to your needs
#gcc -m32 -Wall -Wextra -nostdlib -nostartfiles -nodefaultlibs -Isrc -O5 -fno-strict-aliasing -c \
#    src/start64/start64.c -o build/start64/start64.o
nasm -f elf32 \
    start64.asm -o start64.o
 
# add the contents of $kernel64_section as a section in one of the 32-bit object files
objcopy --add-section      .kernel64="$kernel64_section"  \
        --set-section-flag .kernel64=alloc,data,load,contents \
        start64.o || fail
 
# link the previous two files, taking care to include (-T) the autogenerated syms file
ld -melf_i386 -T linker64.ld -T "$kernel64export32_ldscript" -o kernel64.bin \
   start64.o || fail
