#!/bin/bash

# your 64-bit kernel
KERNEL64="kernel64.elf64"
 
# its base address -- make sure it doesn't overlap with the kernel32 sections!
KERNEL64_BASEADDRESS="0x00140000"
 
# the symbols from it you want available in your 32-bit loader
#KERNEL64EXPORT32_SYMBOLS="k_GDT k_GDTptr k_PML4 k_PML3 k_PML2 k_PML1_first8M kinit64 k_multibootdata k64_sbss k64_ebss k_pages k_npages"
KERNEL64EXPORT32_SYMBOLS="Realm32 Realm64 main"
 
 
KERNEL64EXPORT32_LDSCRIPT=tmp_ld #`mktemp`
KERNEL64_SECTION=tmp_section   #`mktemp`
 
CFLAGS="-m64 -c -O -Wall -Wno-main -O -fstrength-reduce -fomit-frame-pointer -finline-functions -nostdinc -fno-builtin -I . -ffreestanding -mcmodel=large -nostdlib -mno-red-zone -mno-mmx -mno-sse -mno-sse2 -mno-sse3 -mno-3dnow"

nasm -f elf64 -o jump64.o jump64.asm 
gcc $CFLAGS -o main.o main.c
gcc $CFLAGS -o scrn.o scrn.c
gcc $CFLAGS -o lib.o lib.c
ld -nostdlib -nodefaultlibs -T link64.ld  -o $KERNEL64 jump64.o main.o scrn.o lib.o


# I assume that you've already compiled and linked your 64-bit kernel
 
 
# generate .KERNEL64 section's data
readelf -SW "$KERNEL64" | python -c "`cat <<EOF
import re, sys
regex=r"\[\s*\d+\]\s*(?!NULL)(\S+)\s+(PROGBITS|NOBITS)\s+([0-9a-fA-F]+)\s+([0-9a-fA-F]+)\s+([0-9a-fA-F]+)"
baseaddress=$KERNEL64_BASEADDRESS
k64f = open("$KERNEL64", "r")
f = open("$KERNEL64_SECTION", "w")
for line in sys.stdin:
	r = re.search(regex, line)
	if not r:
		continue
	section, stype, LMA, offset, size = r.groups()
	LMA, offset, size = map(lambda s: int(s, 16), (LMA, offset, size))
	if LMA < baseaddress:
		raise ValueError("section ('%s' offset=0x%08x size=0x%08x ) at address < 0x%x" % (section, offset, size, baseaddress))
	k64f.seek(offset)
	if stype == "PROGBITS":
		f.seek(LMA-baseaddress)
		f.write(k64f.read(size))
f.close()
EOF`" || fail
 

# export wanted symbols from KERNEL64
readelf -sW "$KERNEL64" | python -c "`cat <<EOF
import re, sys
regex=r"\s*\:\s+([0-9a-fA-F]+)\s+\d+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+)"
syms=filter(len,"$KERNEL64EXPORT32_SYMBOLS".split(" "))
f = open("$KERNEL64EXPORT32_LDSCRIPT", "w")
for line in sys.stdin:
	r = re.search(regex, line)
	if not r:
		continue
	val, sym = r.groups()
	if not sym in syms:
		continue
	val = int(val, 16)
	if val > 0xffffffff:
		raise ValueError("symbol value must be below 0xffffffff limit")
	f.write('"%s" = %s;\n' % (sym, hex(val)))
f.close()
EOF`" || fail
 

# now we have to build the 32-bit loader
 
# your actual lines may vary, change to your needs
#gcc -m32 -Wall -Wextra -nostdlib -nostartfiles -nodefaultlibs -Isrc -O5 -fno-strict-aliasing -c \
#    src/start64/start64.c -o build/start64/start64.o
nasm -f elf32   start64.asm  -o start64.o
 

# add the contents of $KERNEL64_SECTION as a section in one of the 32-bit object files
objcopy --add-section      .KERNEL64="$KERNEL64_SECTION"  \
        --set-section-flag .KERNEL64=alloc,data,load,contents \
        start64.o || fail
 

# link the previous two files, taking care to include (-T) the autogenerated syms file
ld -melf_i386 -T link_start64.ld -T "$KERNEL64EXPORT32_LDSCRIPT" -o kernel64.bin   start64.o || fail

